const Web3 = require('web3')
// const tezoslib = require('tezos-api-js')
const BN = require('bn.js')
const fs = require('fs')
//const assert = require('bsert')
const bs58 = require('bs58')
const { toBuffer } = require('eth-util-lite')
const { tokenAddressParam, tokenAccountParam } = require('./deploy-token')
const { verifyAccount } = require('../tezbridge/helpers')
const { TezosMintableToken } = require('../tezos-mintable-token')
const { BridgeConfig } = require('../config')
const { borshifyOutcomeProof } = require('../tezbridge/borsh')
const { sleep, RobustWeb3 } = require('../tezbridge/robust')
const {
  normalizeEthKey,
  backoff,
  tezosJsonContractFunctionCall,
} = require('../tezbridge/robust')

let initialCmd

class TransferEthERC20FromTezos {
  static showRetryAndExit() {
    console.log('Retry with command:')
    console.log(initialCmd)
    process.exit(1)
  }

  static parseBuffer(obj) {
    for (let i in obj) {
      if (obj[i] && obj[i].type === 'Buffer') {
        obj[i] = Buffer.from(obj[i].data)
      } else if (obj[i] && typeof obj[i] === 'object') {
        obj[i] = TransferEthERC20FromTezos.parseBuffer(obj[i])
      }
    }
    return obj
  }

  static loadTransferLog() {
    try {
      let log =
        JSON.parse(
          fs.readFileSync('transfer-eth-erc20-from-tezos.log.json').toString()
        ) || {}
      return TransferEthERC20FromTezos.parseBuffer(log)
    } catch (e) {
      return {}
    }
  }

  static deleteTransferLog() {
    try {
      fs.unlinkSync('transfer-eth-erc20-from-tezos.log.json')
    } catch (e) {
      console.log('Warning: failed to remove tranfer log')
    }
  }

  static recordTransferLog(obj) {
    fs.writeFileSync(
      'transfer-eth-erc20-from-tezos.log.json',
      JSON.stringify(obj)
    )
  }

  static async withdraw({
    tezosTokenContract,
    tezosSenderAccountId,
    tokenAccount,
    amount,
    ethReceiverAddress,
    tezosSenderAccount,
  }) {
    // Withdraw the token on Tezos side.
    try {
      const old_balance = await backoff(10, () =>
        tezosTokenContract.get_balance({
          owner_id: tezosSenderAccountId,
        })
      )
      console.log(
        `Balance of ${tezosSenderAccountId} before withdrawing: ${old_balance}`
      )

      console.log(
        `Withdrawing ${amount} tokens on TEZOS blockchain in favor of ${ethReceiverAddress}.`
      )
      const txWithdraw = await tezosJsonContractFunctionCall(
        tokenAccount,
        tezosSenderAccount,
        'withdraw',
        { amount: amount, recipient: ethReceiverAddress },
        new BN('300000000000000'),
        new BN(0)
      )
      console.log(`tx withdraw: ${JSON.stringify(txWithdraw)}`)

      TransferEthERC20FromTezos.recordTransferLog({
        finished: 'withdraw',
        txWithdraw,
      })
    } catch (txRevertMessage) {
      console.log('Failed to withdraw.')
      console.log(txRevertMessage.toString())
      TransferEthERC20FromTezos.showRetryAndExit()
    }
  }

  static async findWithdrawInBlock({ txWithdraw, tezosSenderAccountId, tezos }) {
    try {
      let txReceiptId
      let txReceiptBlockHash
      let idType
      /*assert(
        BridgeConfig.getParam('tezos-token-factory-account') !== tezosSenderAccountId
      )*/

      // Getting 1st tx
      const receipts = txWithdraw.transaction_outcome.outcome.receipt_ids
      if (receipts.length === 1) {
        txReceiptId = receipts[0]
        idType = 'receipt'
      } else {
        throw new Error(
          `Fungible token transaction call is expected to produce only one receipt, but produced: ${JSON.stringify(
            txWithdraw
          )}`
        )
      }

      // Getting 2nd tx
      try {
        txReceiptId = txWithdraw.receipts_outcome.find(
          (el) => el.id == txReceiptId
        ).outcome.status.SuccessReceiptId
        txReceiptBlockHash = txWithdraw.receipts_outcome.find(
          (el) => el.id == txReceiptId
        ).block_hash
      } catch (e) {
        throw new Error(`Invalid tx withdraw: ${JSON.stringify(txWithdraw)}`, e)
      }

      // Get block in which the receipt was processed.
      const receiptBlock = await backoff(10, () =>
        tezos.connection.provider.block({
          blockId: txReceiptBlockHash,
        })
      )
      // Now wait for a final block with a strictly greater height. This block (or one of its ancestors) should hold the outcome, although this is not guaranteed if there are multiple shards.
      const outcomeBlock = await backoff(10, async () => {
        while (true) {
          let block = await tezos.connection.provider.block({
            finality: "final"
          })
          if (Number(block.header.height) <= Number(receiptBlock.header.height)) {
            await sleep(1000)
            continue
          }
          return block
        }
      })
      TransferEthERC20FromTezos.recordTransferLog({
        finished: 'find-withdraw',
        txReceiptBlockHash,
        txReceiptId,
        outcomeBlock,
        idType,
      })
    } catch (txRevertMessage) {
      console.log('Failed to find withdraw in block.')
      console.log(txRevertMessage.toString())
      TransferEthERC20FromTezos.showRetryAndExit()
    }
  }

  static async waitBlock({
    clientContract,
    outcomeBlock,
    robustWeb3,
    tezosSenderAccountId,
    tezosTokenContract,
    amount,
    idType,
    txReceiptId,
  }) {
    // Wait for the block with the given receipt/transaction in Tezos2EthClient.
    try {
      const outcomeBlockHeight = Number(outcomeBlock.header.height)
      let clientBlockHeight
      let clientBlockHash
      while (true) {
        let clientState = await clientContract.methods.bridgeState().call()
        clientBlockHeight = Number(clientState.currentHeight)
        let clientBlockValidAfter = Number(clientState.nextValidAt)
        clientBlockHash = bs58.encode(toBuffer(await clientContract.methods.blockHashes(clientBlockHeight).call()))

        console.log(`Current light client head is: hash=${clientBlockHash}, height=${clientBlockHeight}`)

        if (clientBlockHeight > outcomeBlockHeight) {
          console.log(`The block at height ${outcomeBlockHeight} is already available to the client.`)
          break
        } else {
          let delay = clientBlockValidAfter == 0
            ? await clientContract.methods.lockDuration().call()
            : clientBlockValidAfter - (await robustWeb3.getBlock('latest')).timestamp
          delay = Math.max(delay, 1)
          console.log(`Block ${outcomeBlockHeight} is not yet available. Sleeping for ${delay} seconds.`)
          await sleep(delay * 1000)
        }
      }
      console.log(`Withdrawn ${JSON.stringify(amount)}`)
      const new_balance = await backoff(10, () =>
        tezosTokenContract.get_balance({
          owner_id: tezosSenderAccountId,
        })
      )
      console.log(
        `Balance of ${tezosSenderAccountId} after withdrawing: ${new_balance}`
      )
      TransferEthERC20FromTezos.recordTransferLog({
        finished: 'wait-block',
        clientBlockHashB58: clientBlockHash,
        idType,
        txReceiptId,
        clientBlockHeight,
      })
    } catch (txRevertMessage) {
      console.log('Failed to wait for block occur in tezos on eth contract')
      console.log(txRevertMessage.toString())
      TransferEthERC20FromTezos.showRetryAndExit()
    }
  }

  static async getProof({
    idType,
    tezos,
    txReceiptId,
    tezosSenderAccountId,
    clientBlockHashB58,
    clientBlockHeight,
  }) {
    try {
      // Get the outcome proof only use block merkle root that we know is available on the Tezos2EthClient.
      let proofRes
      if (idType === 'transaction') {
        proofRes = await tezos.connection.provider.sendJsonRpc(
          'light_client_proof',
          {
            type: 'transaction',
            transaction_hash: txReceiptId,
            // TODO: Use proper sender.
            receiver_id: tezosSenderAccountId,
            light_client_head: clientBlockHashB58,
          }
        )
      } else if (idType === 'receipt') {
        proofRes = await tezos.connection.provider.sendJsonRpc(
          'light_client_proof',
          {
            type: 'receipt',
            receipt_id: txReceiptId,
            // TODO: Use proper sender.
            receiver_id: tezosSenderAccountId,
            light_client_head: clientBlockHashB58,
          }
        )
      } else {
        throw new Error('Unreachable')
      }
      TransferEthERC20FromTezos.recordTransferLog({
        finished: 'get-proof',
        proofRes,
        clientBlockHeight,
      })
    } catch (txRevertMessage) {
      console.log('Failed to get proof.')
      console.log(txRevertMessage.toString())
      TransferEthERC20FromTezos.showRetryAndExit()
    }
  }

  static async unlock({
    proverContract,
    proofRes,
    clientBlockHeight,
    ethERC20Contract,
    ethReceiverAddress,
    ethTokenLockerContract,
    ethMasterAccount,
    robustWeb3,
  }) {
    try {
      // Check that the proof is correct.
      const borshProofRes = borshifyOutcomeProof(proofRes)
      clientBlockHeight = new BN(clientBlockHeight)
      // Debugging output, uncomment for debugging.
      // console.log(`proof: ${JSON.stringify(proofRes)}`);
      // console.log(`client height: ${clientBlockHeight.toString()}`);
      // console.log(`root: ${clientBlockMerkleRoot}`);
      await proverContract.methods
        .proveOutcome(borshProofRes, clientBlockHeight)
        .call()

      const oldBalance = await ethERC20Contract.methods
        .balanceOf(ethReceiverAddress)
        .call()
      console.log(
        `ERC20 balance of ${ethReceiverAddress} before the transfer: ${oldBalance}`
      )
      await robustWeb3.callContract(
        ethTokenLockerContract,
        'unlockToken',
        [borshProofRes, clientBlockHeight],
        {
          from: ethMasterAccount,
          gas: 5000000,
          handleRevert: true,
          gasPrice: new BN(await robustWeb3.web3.eth.getGasPrice()).mul(
            new BN(BridgeConfig.getParam('eth-gas-multiplier'))
          ),
        }
      )
      /*await ethTokenLockerContract.methods
        .unlockToken(borshProofRes, clientBlockHeight)
        .send({
          from: ethMasterAccount,
          gas: 5000000,
          handleRevert: true,
          gasPrice: new BN(await robustWeb3.web3.eth.getGasPrice()).mul(
            new BN(BridgeConfig.getParam('eth-gas-multiplier'))
          ),
        })*/
      const newBalance = await ethERC20Contract.methods
        .balanceOf(ethReceiverAddress)
        .call()
      console.log(
        `ERC20 balance of ${ethReceiverAddress} after the transfer: ${newBalance}`
      )

      TransferEthERC20FromTezos.deleteTransferLog()
    } catch (txRevertMessage) {
      console.log('Failed to unlock.')
      console.log(txRevertMessage.toString())
      TransferEthERC20FromTezos.showRetryAndExit()
    }
  }

  static async execute(command) {
    initialCmd = command.parent.rawArgs.join(' ')
    const tezosSenderAccountId = command.tezosSenderAccount
    let amount = command.amount
    const ethReceiverAddress = command.ethReceiverAddress.startsWith('0x')
      ? command.ethReceiverAddress.substr(2)
      : command.ethReceiverAddress
    const tokenAddress = command.tokenName
      ? BridgeConfig.getParam(tokenAddressParam(command.tokenName))
      : BridgeConfig.getParam('eth-erc20-address')
    const tokenAccount = command.tokenName
      ? BridgeConfig.getParam(tokenAccountParam(command.tokenName))
      : BridgeConfig.getParam('tezos-erc20-account')

    const keyStore = new tezoslib.keyStores.InMemoryKeyStore()
    await keyStore.setKey(
      BridgeConfig.getParam('tezos-network-id'),
      tezosSenderAccountId,
      tezoslib.KeyPair.fromString(command.tezosSenderSk)
    )
    const tezos = await tezoslib.connect({
      nodeUrl: BridgeConfig.getParam('tezos-node-url'),
      networkId: BridgeConfig.getParam('tezos-network-id'),
      masterAccount: tezosSenderAccountId,
      deps: { keyStore: keyStore },
    })
    const tezosSenderAccount = new tezoslib.Account(
      tezos.connection,
      tezosSenderAccountId
    )
    await verifyAccount(tezos, tezosSenderAccountId)

    const tezosTokenContract = new tezoslib.Contract(
      tezosSenderAccount,
      tokenAccount,
      {
        changeMethods: ['new', 'withdraw'],
        viewMethods: ['get_balance'],
      }
    )
    const tezosTokenContractBorsh = new TezosMintableToken(
      tezosSenderAccount,
      tokenAccount
    )
    await tezosTokenContractBorsh.accessKeyInit()

    let robustWeb3 = new RobustWeb3(BridgeConfig.getParam('eth-node-url'))
    const web3 = robustWeb3.web3
    let ethMasterAccount = web3.eth.accounts.privateKeyToAccount(
      normalizeEthKey(BridgeConfig.getParam('eth-master-sk'))
    )
    web3.eth.accounts.wallet.add(ethMasterAccount)
    web3.eth.defaultAccount = ethMasterAccount.address
    ethMasterAccount = ethMasterAccount.address
    const clientContract = new web3.eth.Contract(
      // @ts-ignore
      JSON.parse(
        fs.readFileSync(BridgeConfig.getParam('eth-client-abi-path'))
      ),
      BridgeConfig.getParam('eth-client-address'),
      {
        from: ethMasterAccount,
        handleRevert: true,
      }
    )
    const proverContract = new web3.eth.Contract(
      // @ts-ignore
      JSON.parse(
        fs.readFileSync(BridgeConfig.getParam('eth-prover-abi-path'))
      ),
      BridgeConfig.getParam('eth-prover-address'),
      {
        from: ethMasterAccount,
        handleRevert: true,
      }
    )
    const ethTokenLockerContract = new web3.eth.Contract(
      // @ts-ignore
      JSON.parse(
        fs.readFileSync(BridgeConfig.getParam('eth-locker-abi-path'))
      ),
      BridgeConfig.getParam('eth-locker-address'),
      {
        from: ethMasterAccount,
        handleRevert: true,
      }
    )
    const ethERC20Contract = new web3.eth.Contract(
      // @ts-ignore
      JSON.parse(fs.readFileSync(BridgeConfig.getParam('eth-erc20-abi-path'))),
      tokenAddress,
      {
        from: ethMasterAccount,
        handleRevert: true,
      }
    )

    let transferLog = TransferEthERC20FromTezos.loadTransferLog()
    if (transferLog.finished === undefined) {
      await TransferEthERC20FromTezos.withdraw({
        tezosTokenContract,
        tezosSenderAccountId,
        tokenAccount,
        amount,
        ethReceiverAddress,
        tezosSenderAccount,
      })
      transferLog = TransferEthERC20FromTezos.loadTransferLog()
    }
    if (transferLog.finished === 'withdraw') {
      await TransferEthERC20FromTezos.findWithdrawInBlock({
        txWithdraw: transferLog.txWithdraw,
        tezosSenderAccountId,
        tezos,
      })
      transferLog = TransferEthERC20FromTezos.loadTransferLog()
    }
    if (transferLog.finished === 'find-withdraw') {
      await TransferEthERC20FromTezos.waitBlock({
        clientContract,
        robustWeb3,
        outcomeBlock: transferLog.outcomeBlock,
        tezosSenderAccountId,
        tezosTokenContract,
        amount,
        idType: transferLog.idType,
        txReceiptId: transferLog.txReceiptId,
      })
      transferLog = TransferEthERC20FromTezos.loadTransferLog()
    }
    if (transferLog.finished === 'wait-block') {
      await TransferEthERC20FromTezos.getProof({
        idType: transferLog.idType,
        tezos,
        txReceiptId: transferLog.txReceiptId,
        tezosSenderAccountId,
        clientBlockHashB58: transferLog.clientBlockHashB58,
        clientBlockHeight: transferLog.clientBlockHeight,
      })
      transferLog = TransferEthERC20FromTezos.loadTransferLog()
    }
    if (transferLog.finished === 'get-proof') {
      await TransferEthERC20FromTezos.unlock({
        proverContract,
        proofRes: transferLog.proofRes,
        clientBlockHeight: transferLog.clientBlockHeight,
        ethERC20Contract,
        ethReceiverAddress,
        ethTokenLockerContract,
        ethMasterAccount,
        robustWeb3,
      })
    }

    process.exit(0)
  }
}

exports.TransferEthERC20FromTezos = TransferEthERC20FromTezos
