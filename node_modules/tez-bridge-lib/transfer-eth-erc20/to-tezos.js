// below code can be used as example script/backend to build a DApp leveraging ETH-XTZ bridge
// need to have:
// erc20 token, erc20 locker on ETH chain
// ethClient, eth-prover on XTZ chain
// ETH-XTZ relayer up and running

const utils = require('ethereumjs-util')
const BN = require('bn.js')
const fs = require('fs')
const {
  EthProofExtractor,
  receiptFromWeb3,
  logFromWeb3,
} = require('../eth-proof-extractor')
const { tokenAddressParam, tokenAccountParam } = require('./deploy-token')
const { verifyAccount } = require('../tezbridge/helpers')
const { TezosMintableToken } = require('../tezos-mintable-token')
const { BridgeConfig } = require('../config')

//using contract created here itself, rust contracts are complex and needed schema to interact with, 
//const { ethOnTezosClientContract } = require('../eth-on-tezos-client')
const { sleep, RobustWeb3, normalizeEthKey } = require('../tezbridge/robust')
const { TezosToolkit } = require("@taquito/taquito")
const { InMemorySigner } = require("@taquito/signer")


let initialCmd

class TransferETHERC20ToTezos {
  static showRetryAndExit() {
    console.log('Retry with command:')
    console.log(initialCmd)
    process.exit(1)
  }

  static async approve({
    robustWeb3,
    ethERC20Contract,
    amount,
    ethSenderAccount,
  }) {
    // Approve tokens for transfer.
    const lockerAddress = BridgeConfig.getParam('eth-locker-address')
    try {
      console.log(
        `Approving token transfer to ${lockerAddress} ${Number(amount)}.`
      )
      await robustWeb3.callContract(
        ethERC20Contract,
        'approve',
        [lockerAddress, Number(amount)],
        {
          from: ethSenderAccount,
          gas: 5000000,
        }
      )
      console.log('Approved token transfer.')
      TransferETHERC20ToTezos.recordTransferLog({ finished: 'approve' })
    } catch (txRevertMessage) {
      console.log('Failed to approve.')
      console.log(txRevertMessage.toString())
      TransferETHERC20ToTezos.showRetryAndExit()
    }
  }

  static async lock({
    robustWeb3,
    ethTokenLockerContract,
    tokenAddress,
    amount,
    tezosReceiverAccount,
    ethSenderAccount,
  }) {
    try {
      console.log(
        `Transferring tokens from the ERC20 account to the token locker account ${Number(
          amount
        )}.`
      )
      const transaction = await robustWeb3.callContract(
        ethTokenLockerContract,
        'lockToken',
        [tokenAddress, Number(amount), tezosReceiverAccount],
        {
          from: ethSenderAccount,
          gas: 5000000,
        }
      )
      // console.log(transaction)
      const lockedEvent = transaction.events.Locked
      console.log('Success tranfer to locker')
      TransferETHERC20ToTezos.recordTransferLog({
        finished: 'lock',
        lockedEvent,
      })
    } catch (txRevertMessage) {
      console.log('Failed to lock account.')
      console.log(txRevertMessage.toString())
      TransferETHERC20ToTezos.showRetryAndExit()
    }
  }

  static async findProof({ extractor, lockedEvent, web3 }) {
    const receipt = await extractor.extractReceipt(lockedEvent.transactionHash)
    const block = await extractor.extractBlock(receipt.blockNumber)
    const tree = await extractor.buildTrie(block)
    const proof = await extractor.extractProof(
      web3,
      block,
      tree,
      receipt.transactionIndex
    )
    let txLogIndex = -1

    let logFound = false
    let log
    for (let receiptLog of receipt.logs) {
      txLogIndex++
      const blockLogIndex = receiptLog.logIndex
      if (blockLogIndex === lockedEvent.logIndex) {
        logFound = true
        log = receiptLog
        break
      }
    }
    if (logFound) {
      TransferETHERC20ToTezos.recordTransferLog({
        finished: 'find-proof',
        proof,
        log,
        txLogIndex,
        receipt,
        lockedEvent,
        block,
      })
    } else {
      console.log(`Failed to find log for event ${lockedEvent}`)
      TransferETHERC20ToTezos.showRetryAndExit()
    }
  }

  static async waitBlockSafe({
    log,
    proof,
    receipt,
    txLogIndex,
    lockedEvent,
    block,
    ethOnTezosClientContract,
  }) {
    const log_entry_data = logFromWeb3(log).serialize()
    const receipt_index = proof.txIndex
    const receipt_data = receiptFromWeb3(receipt).serialize()
    const header_data = proof.header_rlp
    const _proof = []
    for (const node of proof.receiptProof) {
      _proof.push(utils.rlp.encode(node))
    }

    const proof_locker = {
      log_index: txLogIndex,
      log_entry_data: log_entry_data,
      receipt_index: receipt_index,
      receipt_data: receipt_data,
      header_data: header_data,
      proof: _proof,
    }

    const new_owner_id = lockedEvent.returnValues.accountId
    const amount = lockedEvent.returnValues.amount
    console.log(
      `Transferring ${amount} tokens from ${lockedEvent.returnValues.token} ERC20. From ${lockedEvent.returnValues.sender} sender to ${new_owner_id} recipient`
    )

    const ethTxblockNumber = block.number
    // Wait until client accepts this block number.
    while (true) {
      // @ts-ignore
      const ethClientStorage = await ethOnTezosClientContract.storage()
      const clientBlockNumber = (ethClientStorage.latest_block).toNumber();
      console.log("current ethClientOnTezos block-number: "+ clientBlockNumber + "  ethTx block-number: "+ ethTxblockNumber)

      // block_hash_safe is already being called by ethTxLogEntriesProver when minting the tokens.
      // when simple viewer functions call from  Javascript are figured good to call block_hash_safe as it verifies along with
      // number of confirmations build into the client and prover so we can initiate txs on Tezos. 
      
      // const is_safe = await ethOnTezosClientContract.block_hash_safe(ethTxBlockNumber)
      
      let  is_safe = false
      if(clientBlockNumber > ethTxblockNumber){
        console.log("eth Tx block Number is safe ")
        //atleast one confirmation for now.
        is_safe = true
      } 
      if (!is_safe) {
        const delay = 10
        console.log(
          `Eth Client contract on Tezos is currently at block ${clientBlockNumber}. Waiting for block ${ethTxblockNumber} to be confirmed. Sleeping for ${delay} sec.`
        )
        await sleep(delay * 1000)
      } else {
        break
      }
    }
   
    TransferETHERC20ToTezos.recordTransferLog({
      finished: 'block-safe',
      proof_locker,
      lockedEvent
    })
  }

  static async deposit({
    proof_locker,
    tezosFA2TokenContract,
    lockedEvent
  }) {
    
    // @ts-ignore
    try {
      // console.log(new_owner_id)
      const new_owner_id = lockedEvent.returnValues.accountId
      const amount = lockedEvent.returnValues.amount
      // const tokenId = lockedEvent.returnValues.tokenId
      //tokenId also needed to be sent to the eth locker contract so can be emitted in the event log
      const tokenId = 0
    
      
      console.log("checking old balance of tezos ERC20-FA2 Token before decentralised_mint call");
      const txOp = await tezosFA2TokenContract.methods.balance_viewer(new_owner_id,tokenId).send()
      console.log("balance viewer txHash "+ txOp.hash)
      //wait till confirmation, or else we are viewing the old balance
      await txOp.confirmation();
      console.log("balance viewer tx confirmed");
      
      let storage = await tezosFA2TokenContract.storage()
      const old_balance = (storage.viewer).toNumber()
     console.log(
      `Old Balance of ${new_owner_id} before the transfer is ${old_balance}`
      )



      // console.log(proof_locker)
       // send lockedEvent and proofLocker as well to  mint call,
       // eth prover contract verifies merkle proofs of log state root(log entries of tx)
       // decentralised_mint calls eth-prover contract and verifies merkle-root, block header hash of canonical chain.
       
       
       const txOp1 = await tezosFA2TokenContract.methods.decentralised_mint(new_owner_id, amount ,'ERC-20-FA2',tokenId).send()
       console.log(" mint tezos FA2 Token tx hash:  "+ txOp1.hash)

       await txOp1.confirmation();
       console.log( "mint tx confirmed")

    
       //check balance here   
       const txOp2 = await tezosFA2TokenContract.methods.balance_viewer(new_owner_id,tokenId).send()
       console.log("balance viewer txHash "+ txOp2.hash)
       //wait till confirmation, or else we are viewing the old balance
       await txOp2.confirmation();
       console.log("balance viewer tx confirmed");
       
       storage = await tezosFA2TokenContract.storage()
       const new_balance = (storage.viewer).toNumber()
      console.log(
       `Balance of ${new_owner_id} after the transfer is ${new_balance}`
       )
      
    
       console.log('Transferred')
    } catch (e) {
      console.log('Deposit failed with error:')
      console.log(e)
      TransferETHERC20ToTezos.showRetryAndExit()
    }



       
    
  
    TransferETHERC20ToTezos.deleteTransferLog()
  }

  static recordTransferLog(obj) {
    fs.writeFileSync('transfer-eth-erc20-to-tezos.log.json', JSON.stringify(obj))
  }

  static parseBuffer(obj) {
    for (let i in obj) {
      if (obj[i] && obj[i].type === 'Buffer') {
        obj[i] = Buffer.from(obj[i].data)
      } else if (obj[i] && typeof obj[i] === 'object') {
        obj[i] = TransferETHERC20ToTezos.parseBuffer(obj[i])
      }
    }
    return obj
  }

  static loadTransferLog() {
    try {
      let log =
        JSON.parse(
          fs.readFileSync('transfer-eth-erc20-to-tezos.log.json').toString()
        ) || {}
      return TransferETHERC20ToTezos.parseBuffer(log)
    } catch (e) {
      return {}
    }
  }

  static deleteTransferLog() {
    try {
      fs.unlinkSync('transfer-eth-erc20-to-tezos.log.json')
    } catch (e) {
      console.log('Warning: failed to remove tranfer log')
    }
  }

  static async execute(command) {
    initialCmd = command.parent.rawArgs.join(' ')
    let transferLog = TransferETHERC20ToTezos.loadTransferLog()
    const amount = command.amount
    const ethSenderSk = command.ethSenderSk
    const tezosReceiverAccount = command.tezosReceiverAccount
    const tokenAddress = command.tokenName
      ? BridgeConfig.getParam(tokenAddressParam(command.tokenName))
      : BridgeConfig.getParam('eth-erc20-address')
    const tokenAccount = command.tokenName
      ? BridgeConfig.getParam(tokenAccountParam(command.tokenName))
      : BridgeConfig.getParam('tezos-erc20-account')
    console.log(`Using ETH ERC-20 Token address ${tokenAddress}`)

    // @ts-ignore
    let robustWeb3 = new RobustWeb3(BridgeConfig.getParam('eth-node-url'))
    let web3 = robustWeb3.web3
    let ethSenderAccount = web3.eth.accounts.privateKeyToAccount(
      normalizeEthKey(ethSenderSk)
    )
    // console.log("ethereum sender key: " + ethSenderSk)
    web3.eth.accounts.wallet.add(ethSenderAccount)
    web3.eth.defaultAccount = ethSenderAccount.address
    ethSenderAccount = ethSenderAccount.address

    const ethERC20Contract = new web3.eth.Contract(
      // @ts-ignore
      JSON.parse(fs.readFileSync(BridgeConfig.getParam('eth-erc20-abi-path'))),
      tokenAddress
    )

    //tezos rpc and contracts: client, FA2Token
    const rpcUrl = 'https://carthagenet.smartpy.io';
    console.log("connecting to Tezos chain: "+ rpcUrl)
    const Tezos = new TezosToolkit(rpcUrl);
    Tezos.setProvider({ signer: new InMemorySigner("edskS55BvqKJeVQKKxLRyqdbWenmPkPoPna4T2J7GWVmC96sE9pvyVK7iHvinVqVzSNe7qGpiVzfv3Fjv48YaUu9i5Z5bPErfR") }); //needed to make txs   

    const tezosFA2TokenContract = await Tezos.contract.at('KT1KTBBQe2wysF36SnjZ2iRyJguwLyQMAXfg')
    // const methods = await tezosFA2TokenContract.methods
    // console.log(methods)
  
    //Todo: remove hardcodings connecting all config params to BridgeConfig 
    const ethOnTezosClientContract = await Tezos.contract.at('KT1LGWCrePidXoH85BgGgnoyuwX9hBy9iKbx')
    // console.log(ethOnTezosClientContract)
    // console.log(await ethOnTezosClientContract.storage())
    

    const extractor = new EthProofExtractor()
    extractor.initialize(BridgeConfig.getParam('eth-node-url'))

    const ethTokenLockerContract = new web3.eth.Contract(
      // @ts-ignore
      JSON.parse(
        fs.readFileSync(BridgeConfig.getParam('eth-locker-abi-path'))
      ),
      BridgeConfig.getParam('eth-locker-address')
    )



    if (transferLog.finished === undefined) {
      
      // Mint tokens first
      await ethERC20Contract.methods
        .mint(ethSenderAccount, Number(amount))
        .send({ from: ethSenderAccount, gas: 5000000 })
      console.log(
        'Balance: ',
        await ethERC20Contract.methods.balanceOf(ethSenderAccount).call()
      )
      await TransferETHERC20ToTezos.approve({
        robustWeb3,
        ethERC20Contract,
        amount,
        ethSenderAccount,
      })
      transferLog = TransferETHERC20ToTezos.loadTransferLog()
    }
    if (transferLog.finished === 'approve') {
      await TransferETHERC20ToTezos.lock({
        robustWeb3,
        ethTokenLockerContract,
        tokenAddress,
        amount,
        tezosReceiverAccount,
        ethSenderAccount,
      })
      transferLog = TransferETHERC20ToTezos.loadTransferLog()
    }
    if (transferLog.finished === 'lock') {
      await TransferETHERC20ToTezos.findProof({
        extractor,
        lockedEvent: transferLog.lockedEvent,
        web3,
      })
      transferLog = TransferETHERC20ToTezos.loadTransferLog()
    }
    if (transferLog.finished === 'find-proof') {
      // console.log(ethOnTezosClientContract)
      await TransferETHERC20ToTezos.waitBlockSafe({
        ethOnTezosClientContract,
        ...transferLog,
      })
      transferLog = TransferETHERC20ToTezos.loadTransferLog()
    }
    // console.log(transferLog)
    if (transferLog.finished === 'block-safe') {
      await TransferETHERC20ToTezos.deposit({        
        tezosFA2TokenContract,
        ...transferLog,
      })
    }

    try {
      // Only WebSocket provider can close.
      web3.currentProvider.connection.close()
    } catch (e) {}
    process.exit(0)
  }
}

exports.TransferETHERC20ToTezos = TransferETHERC20ToTezos
